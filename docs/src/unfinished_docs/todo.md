# Todo list

## High priority

- [ ] add balanced growth path handling
- [ ] add JOSS article (see Makie.jl)
- [ ] write docs for (non-linear) solution algorithms
- [ ] for cond forecastind and kalman, get rid of observables input and use axis key of data input
- [ ] for cond forecasting allow less shocks than conditions with a warning. should be svd then
- [ ] have parser accept rss | (r[ss] - 1) * 400 = rss
- [ ] when doing calibration with optimiser have better return values when he doesnt find a solution (probably NaN)
- [ ] sampler returned negative std. investigate and come up with solution ensuring sampler can continue
- [ ] automatically adjust plots for different legend widhts and heights
- [ ] include weakdeps: https://pkgdocs.julialang.org/dev/creating-packages/#Weak-dependencies
- [ ] write to mod file for unicode characters. have them take what you would type: \alpha\bar
- [ ] have get_std take variables as an input
- [ ] more informative errors when something goes wrong when writing a model
- [ ] initial state accept keyed array
- [ ] bring solution error into an object of the model so we dont have to pass it on as output
- [ ] check that there is an error if he cant find SS
- [ ] plot_model_estimates with unconditional forecast at the end
- [ ] check if you can do analytic derivatives for higher order derivatives
- [ ] kick out unused parameters from m.parameters
- [ ] higher order solution derivs with Zygote
- [ ] use cache for gradient calc in estimation (see DifferentiableStateSpaceModels)
- [ ] use krylov instead of linearsolve and speed up sparse matrix calcs in implicit diff of higher order funcs
- [ ] improve docs: timing in first sentence seems off; have something more general in first sentence; why is the syntax user friendly? give an example; make the former and the latter a footnote
- [ ] streamline estimation part (dont do string matching... but rely on precomputed indices...)
- [ ] change docs to reflect that the output of irfs include aux vars and also the model info Base.show includes aux vars
- [ ] write functions to debug (fix_SS.jl...)
- [ ] parser model into per equation functions instead of single big functions
- [ ] model compression (speed up 2nd moment calc (derivatives) for large models; gradient loglikelihood is very slow due to large matmuls) -> model setup as maximisation problem (gEcon) -> HANK models
- [ ] implement global solution methods
- [ ] add more models
- [ ] plot multiple solutions or models - multioptions in one graph
- [ ] write documentation/docstrings

- [ ] use @assert for errors and @test_throws
- [ ] print SS dependencies (get parameters (in function of parameters) into the dependencies), show SS solver
- [ ] make the nonnegativity trick optional or use nanmath?
- [ ] use packages for kalman filter
- [ ] clean up different parameter types
- [ ] clean up printouts/reporting
- [ ] clean up function inputs and harmonise AD and standard commands
- [ ] figure out combinations for inputs (parameters and variables in different formats for get_irf for example)
- [ ] Find any SS by optimising over both SS guesses and parameter inputs
- [ ] weed out SS solver and saved objects

- [x] fix ss of pruned solution in plotsolution. seems detached
- [x] get solution higher order with multidimensional array (states, 1 and 2 partial derivatives variables names as dimensions in 2order case)
- [x] add pruning
- [x] add other outputs from estimation (smoothed, filter states and shocks)
- [x] shorten plot_irf (take inspiration from model estimate)
- [x] fix solution plot
- [x] see if we can avoid try catch and test for invertability instead
- [x] have Flux solve SS field #gradient descent based is worse than LM based
- [x] have parameters keyword accept Int and 2/3
- [x] plot_solution colors change from 2nd to 2rd order
- [x] custom LM: optimize for other RBC models, use third order backtracking
- [x] add SSS for third order (can be different than the one from 2nd order, see Gali (2015)) in solution plot; also put legend to the bottom as with Condition
- [x] check out Aqua.jl as additional tests
- [x] write tests and documentation for solution, estimation... making sure results are consistent
- [x] catch cases where you define calibration equation without declaring conditional variable
- [x] flag if equations contain no info for SS, suggest to set ss values as parameters
- [x] handle SS case where there are equations which have no information for the SS. use SS definitions in parameter block to complete system | no, set steady state values to parameters instead. might fail if redundant equation has y[0] - y[-1] instead of y[0] - y[ss]
- [x] try eval instead of runtimegeneratedfunctions; eval is slower but can be typed
- [x] check correctness of solution for models added
- [x] SpecialFunctions eta and gamma cause conflicts; consider importing used functions explicitly
- [x] bring the parsing of equations after the parameters macro
- [x] rewrite redundant var part so that it works with ss_aux_equations instead of ss_equations
- [x] catch cases where ss vars are set to zero. x[0] * eps_z[x] in SS becomes x[0] * 0 but should be just 0 (use sympy for this)
- [x] remove duplicate nonnegative aux vars to speed up SS solver
- [x] error when defining variable more than once in parameters macro
- [x] consolidate aux vars, use sympy to simplify
- [x] error when writing equations with only one variable
- [x] error when defining variable as parameter
- [x] more options for IRFs, simulate only certain shocks - set stds to 0 instead
- [x] add NBTOOLBOX, IRIS to overview
- [x] input field for SS init guess in all functions #not necessary so far. SS solver works out everything just fine
- [x] symbolic derivatives
- [x] check SW03 SS solver
- [x] more options for IRFs, pass on shock vector
- [x] write to dynare
- [x] add plot for policy function
- [x] add plot for FEVD
- [x] add functions like get_variance, get_sd, get_var, get_covar
- [x] add correlation, autocorrelation, and (conditional) variance decomposition
- [x] go through docs to reflect verbose behaviour
- [x] speed up covariance mat calc
- [x] have conditional parameters at end of entry as well (... | alpha instead of alpha | ...)
- [x] Get functions: get_output, get_moments
- [x] get rid of init_guess
- [x] an and schorfheide estimation
- [x] estimation, IRF matching, system priors
- [x] check derivative tests with finite diff
- [x] release first version
- [x] SS solve: add domain transformation optim
- [x] revisit optimizers for SS
- [x] figure out licenses
- [x] SS: replace variables in log() with auxilliary variable which must be positive to help solver
- [x] complex example with lags > 1, [ss], calib equations, aux nonneg vars
- [x] add NLboxsolve
- [x] try NonlinearSolve - fails due to missing bounds
- [x] make noneg aux part of optim problem for NLboxsolve in order to avoid DomainErrors - not necessary
- [x] have bounds on alpha (failed previously due to naming conflict) - works now

## Not high priority

- [ ] estimation codes with missing values (adopt kalman filter)
- [ ] whats a good error measure for higher order solutions (taking whole dist of future shock into account)? use mean error for n number of future shocks
- [ ] improve redundant calculations of SS and other parts of solution
- [ ] restructure functions and containers so that compiler knows what types to expect
- [ ] use RecursiveFactorization and TriangularSolve to solve, instead of MKL or OpenBLAS
- [ ] fix SnoopCompile with generated functions
- [ ] rewrite first order with riccati equation MatrixEquations.jl
- [ ] exploit variable incidence and compression for higher order derivatives
- [ ] for estimation use CUDA with st order: linear time iteration starting from last 1st order solution and then LinearSolveCUDA solvers for higher orders. this should bring benefits for large models and HANK models
- [ ] pull request in StatsFuns to have norminv... accept type numbers and add translation from matlab: norminv to StatsFuns norminvcdf
- [ ] more informative errors when declaring equations/ calibration
- [ ] unit equation errors
- [ ] implenent reduced linearised system solver + nonlinear
- [ ] implement HANK
- [ ] implement automatic problem derivation (gEcon)
- [ ] print legend for algorithm in last subplot of plot only
- [ ] select variables for moments

- [x] test on highly [nonlinear model](https://www.sciencedirect.com/science/article/pii/S0165188917300970) # caldara et al is actually epstein zin wiht stochastic vol
- [x] conditional forecasting
- [x] find way to recover from failed SS solution which is written to init guess
- [x] redo ugly solution for selecting parameters to differentiate for
- [x] conditions for when to use which solution. if solution is outdated redo all solutions which have been done so far and use smart starting points
- [x] Revise 2,3 pert codes to make it more intuitive
- [x] implement blockdiag with julia package instead of python
- [x] Pretty print linear solution
- [x] write function to get_irfs
- [x] Named arrays for irf
- [x] write state space function for solution
- [x] Status print for model container
- [x] implenent 2nd + 3rd order perturbation
- [x] implement fuctions for distributions
- [x] try speedmapping.jl - no improvement
- [x] moment matching
- [x] write tests for higher order pert and standalone function
- [x] add compression back in
- [x] FixedPointAcceleration didnt improve on iterative procedure
- [x] add exogenous variables in lead or lag
- [x] regex in parser of SS and exo
- [x] test SS solver on SW07
- [x] change calibration, distinguish SS/dyn parameters
- [x] plot multiple solutions at same time (save them in separate constructs)
- [x] implement bounds in SS finder
- [x] map pars + vars impacting SS
- [x] check bounds when putting in new calibration
- [x] Save plot option
- [x] Add shock to plot title
- [x] print model name
